# WARNING - Generated by {fusen} from /dev/flat_create_new_project_gitlab.Rmd: do not edit by hand

library(gitlabr)
library(dplyr)

skip_on_ci()
skip_if_offline()

gitlab_url <- Sys.getenv("GITLAB_URL", unset = "https://gitlab.com")

the_token <- Sys.getenv("GITLAB_TOKEN")

options(
  remotes.git_credentials =
    git2r::cred_user_pass("gitlab-ci-token", the_token)
)

# GitLab con
my_gitlab <- gl_connection(
  gitlab_url = gitlab_url,
  private_token = the_token
)

# Set the connection for the session
set_gitlab_connection(my_gitlab)

# Get user infos
user_info <- gitlab(req = paste0("user"), verb = httr::GET)
user_name <- user_info %>% pull(username)

project_name <- paste0("lozenprojectforunittest")

# Get user namespace (= group_id)
# namespace_id <- gitlabr::gitlab(req = "namespaces", search = user_name)[["id"]]
group_url <- user_info[["web_url"]]


# create_group_project ----
test_that("create_group_project works", {
  expect_message(create_group_project(project_name, namespace_id = NULL))
})

expect_message(
  project_id <- create_group_project(project_name, namespace_id = NULL, default_branch = "main"),
  regexp = "already exists"
)

# add_labels ----
test_that("add_labels works", {
  ## Add new
  add_labels(project_id)

  ## Add again but nothing append
  expect_message(labels <- add_labels(project_id), "No new labels to add")

  expect_equal(nrow(labels), 0)
})

# add_board ----
test_that("add_board works", {
  board <- add_board(project_id)

  expect_equal(nrow(board), 1)
})

# add_issue_clients ----
test_that("add_issue_clients works", {
  expect_message(issue <- add_issue_clients(project_id, project_name, group_url), "Issue Client")
  expect_equal(issue[["iid"]], "1")
})

# add_wikis ----
test_that("add_wikis works", {
  expect_message(
    wiki <- add_wikis(project_id, project_name, group_url, group = basename(group_url)),
    "Wiki home"
  )
  expect_equal(nrow(wiki), 3)
})

# clone_locally ----
test_that("clone_locally works", {
  expect_message(
    clone <- clone_locally(project_name, group_url, open = FALSE)
  )
  expect_true(dir.exists(clone))
  expect_true(dir.exists(file.path(clone, ".git")))
  # expect_equal(clone, project_path)
  unlink(clone, recursive = TRUE)
})

expect_error(
  project_path <- clone_locally(project_name, group_url, open = FALSE),
  regexp = NA
)

expect_message(
  r_project <- create_r_project(project_path, type = c("package"), name_licence = "test", type_licence = usethis::use_mit_license),
  "package created"
)

# push_main ----
test_that("push_main works", {
  expect_message(push_main(project_path))
  # Verify on GitLab
  branches <- gitlabr::gl_list_branches(project_id)
  expect_true(branches[["name"]] %in% c("main", "master"))
})

# create_production ----
test_that("create_production works", {
  expect_message(create_production(project_path))
  branche <- gitlabr::gl_get_branch(project_id, "production")
  expect_true(nrow(branche) > 0)
})

# protect_branches ----
test_that("protect_branches works", {
  expect_message(protect_branches(project_id))
  p_branches <- gitlab(
    req = paste0("projects/", project_id, "/protected_branches"),
    verb = httr::GET
  )
  expect_equal(p_branches[["push_access_levels.access_level"]], c("0", "0", "0"))
})

# modify_autoclose_and_coverage ----
test_that("modify_autoclose_and_coverage works", {
  expect_message(modify_autoclose_and_coverage(project_id))
})

# Modify project_options ----
test_that("project_options works", {
  expect_message(project_options(project_id), "Notification setting set for you only: watch")
})

# add_issue_dev ----
test_that("add_issue_dev works", {
  expect_message(add_issue_dev(project_id, group_url, project_name))
  issues_list <- gl_list_issues(project = project_id)
  expect_true(any(grepl("Checklist", issues_list[["title"]])))
})

# Clean
unlink(project_path, recursive = TRUE)

# Clean GitLab => Remove the project
gitlab(
  req = paste0("projects/", project_id),
  verb = httr::DELETE
)

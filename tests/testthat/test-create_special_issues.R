# WARNING - Generated by {fusen} from /dev/flat_create_special_issues.Rmd: do not edit by hand

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITLAB_TOKEN") != "")
test_that("add_issue_clients works", {
  expect_true(inherits(add_issue_clients, "function"))

  gitlab_url <- Sys.getenv("GITLAB_URL", unset = "https://gitlab.com")

  the_token <- Sys.getenv("GITLAB_TOKEN")

  options(
    remotes.git_credentials =
      git2r::cred_user_pass("gitlab-ci-token", the_token)
  )

  # GitLab con
  my_gitlab <- gl_connection(
    gitlab_url = gitlab_url,
    private_token = the_token
  )

  # Set the connection for the session
  set_gitlab_connection(my_gitlab)

  # Get user infos
  user_info <- gitlab(req = paste0("user"), verb = httr::GET)
  user_name <- user_info %>% pull(username)

  project_name <- "lozenexempleissues5"

  # Get user namespace (= group_id)
  # namespace_id <- gitlabr::gitlab(req = "namespaces", search = user_name)[["id"]]
  group_url <- user_info[["web_url"]]


  # create_group_project ----
  project_id <- create_group_project(project_name, namespace_id = NULL)


  # create issue text and send to gitlab
  issue_client_id <- add_issue_clients(
    project_id = project_id,
    project_name = project_name,
    group_url = gitlab_url
  )

  issues_open <- gl_list_issues(
    project = project_id,
    state = "opened",
    max_pages = 1
  )

  expect_equal(
    object = issues_open[["title"]][1],
    expected = "Bienvenue sur le suivi de projet GitLab"
  )

  expect_equal(
    object = issues_open[["labels"]][1],
    expected = "Bloqu\u00e9"
  )

  # suppress issue once check is passed
  gitlabr::gl_delete_issue(
    project = project_id,
    issue_id = issue_client_id$iid
  )

  # Clean GitLab => Remove the project
  gitlabr::gitlab(
    req = paste0("projects/", project_id),
    verb = httr::DELETE
  )
})

test_that("create_issue_content_clients works", {
  expect_true(inherits(create_issue_content_clients, "function"))

  project_name <- "testprojectname"
  group_url <- "https://gitlab.com/test/"


  object_to_test <- create_issue_content_clients(
    project_name = project_name,
    group_url = group_url
  )

  #' @description Testing that project_name is inside the content text
  expect_match(object = object_to_test, regexp = project_name, all = FALSE)
  #' @description Testing that group_url is inside the content text
  expect_match(object = object_to_test, regexp = group_url, all = FALSE)
})

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITLAB_TOKEN") != "")
test_that("add_issue_dev works", {
  expect_true(inherits(add_issue_dev, "function"))

  gitlab_url <- Sys.getenv("GITLAB_URL", unset = "https://gitlab.com")

  the_token <- Sys.getenv("GITLAB_TOKEN")

  # GitLab con
  my_gitlab <- gl_connection(
    gitlab_url = gitlab_url,
    private_token = the_token
  )

  # Set the connection for the session
  set_gitlab_connection(my_gitlab)

  # Get user infos
  user_info <- gitlab(req = paste0("user"), verb = httr::GET)
  user_name <- user_info %>% pull(username)

  project_name <- "lozenexempleissues2"

  # Get user namespace (= group_id)
  # namespace_id <- gitlabr::gitlab(req = "namespaces", search = user_name)[["id"]]
  group_url <- user_info[["web_url"]]


  # create_group_project ----
  project_id <- create_group_project(project_name, namespace_id = NULL)


  issue_dev <- add_issue_dev(
    project_id = project_id,
    group_url = group_url,
    project_name = project_name
  )

  expect_equal(
    object = issue_dev[["title"]][1],
    expected = "[dev] Checklist mise en place"
  )

  expect_equal(
    object = issue_dev[["labels"]][1],
    expected = "Bloqu\u00e9"
  )

  # suppress issue once check is passed
  gitlabr::gl_delete_issue(
    project = project_id,
    issue_id = issue_dev$iid
  )

  # Clean GitLab => Remove the project
  gitlab(
    req = paste0("projects/", project_id),
    verb = httr::DELETE
  )
})

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITLAB_TOKEN") != "")
test_that("create_issue_content_dev works", {
  expect_true(inherits(create_issue_content_dev, "function"))

  gitlab_url <- Sys.getenv("GITLAB_URL", unset = "https://gitlab.com")

  the_token <- Sys.getenv("GITLAB_TOKEN")

  # GitLab con
  my_gitlab <- gl_connection(
    gitlab_url = gitlab_url,
    private_token = the_token
  )

  # Set the connection for the session
  set_gitlab_connection(my_gitlab)

  # Get user infos
  user_info <- gitlab(req = paste0("user"), verb = httr::GET)
  user_name <- user_info %>% pull(username)

  project_name <- "lozenexempleissues3"

  # Get user namespace (= group_id)
  # namespace_id <- gitlabr::gitlab(req = "namespaces", search = user_name)[["id"]]
  group_url <- user_info[["web_url"]]


  # create_group_project ----
  project_id <- create_group_project(project_name, namespace_id = NULL)


  object_to_test <- create_issue_content_dev(project_id = project_id, group_url = group_url, project_name = project_name)


  #' @description Testing that project_name is inside the content text
  expect_match(object = object_to_test, regexp = project_name, all = FALSE)
  #' @description Testing that group_url is inside the content text
  expect_match(object = object_to_test, regexp = group_url, all = FALSE)
  #' @description Testing that if is the first issue then we find NA inside the content text
  expect_match(object = object_to_test, regexp = "NA", all = FALSE)

  # Clean GitLab => Remove the project
  gitlabr::gitlab(
    req = paste0("projects/", project_id),
    verb = httr::DELETE
  )
})

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITLAB_TOKEN") != "")
test_that("add_issue_kickoff works", {
  gitlab_url <- Sys.getenv("GITLAB_URL", unset = "https://gitlab.com")

  the_token <- Sys.getenv("GITLAB_TOKEN")

  # GitLab con
  my_gitlab <- gl_connection(
    gitlab_url = gitlab_url,
    private_token = the_token
  )

  # Set the connection for the session
  set_gitlab_connection(my_gitlab)

  # Get user infos
  user_info <- gitlab(req = paste0("user"), verb = httr::GET)
  user_name <- user_info %>% pull(username)

  project_name <- "lozenexempleissues4"

  # Get user namespace (= group_id)
  # namespace_id <- gitlabr::gitlab(req = "namespaces", search = user_name)[["id"]]
  group_url <- user_info[["web_url"]]


  # create_group_project ----
  project_id <- create_group_project(project_name, namespace_id = NULL)


  # make kickoff issue
  expect_message(
    kickoff_output <- add_issue_kickoff(project_id = project_id),
    regexp = "Issue Kickoff cr\u00e9\u00e9e",
    all = FALSE
  )

  # check the issue exists and has the correct title
  expect_true(nrow(kickoff_output) == 1)
  expect_match(
    object = kickoff_output[["title"]],
    regexp = "ETQ client, j\'ai compris le fonctionnement de la validation des tickets"
  )

  # check issue is not open when already present
  expect_message(
    object = add_issue_kickoff(project_id = project_id),
    regexp = "Kickoff issue already exists in this project."
  )

  # delete kickoff issue
  gitlabr::gl_delete_issue(
    project = project_id,
    issue_id = kickoff_output[["iid"]]
  )

  # Clean GitLab => Remove the project
  gitlabr::gitlab(
    req = paste0("projects/", project_id),
    verb = httr::DELETE
  )
})

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITLAB_TOKEN") != "")
test_that("create_issue_content_kickoff works", {
  expect_equal(
    object = create_issue_content_kickoff(),
    expected = c(
      "## Validation (Pour les clients)",
      "",
      "- [ ] Je comprend qu\'un ticket est divis\u00e9 en 3 parties: le titre (besoin), les crit\u00e8res de validation et une partie technique",
      "- [ ] Je comprend que la partie validation est celle qui me concerne en tant client et que toutes les informations pour valider le ticket y sont pr\u00e9sentes",
      "- [ ] J\'ai \u00e9t\u00e9 inform\u00e9 que la partie validation est auto-portante: toutes les informations permettant de valider seront pr\u00e9sentes et compl\u00e9t\u00e9e avec des captures d\'\u00e9cran ou url \u00e0 explorer",
      "- [ ] Je comprend que la partie technique ne concernent que les personnes qui d\u00e9veloppent",
      "- [ ] Je comprend que pour valider ce ticket, je dois ajouter un commentaire ci-dessous pour indiquer que je valide la totalit\u00e9 du ticket et qu\'il peut \u00eatre ferm\u00e9. Le cas \u00e9ch\u00e9ant, j\'indique les corrections \u00e0 apporter",
      "",
      "## Technique (Pour les devs)",
      "",
      "+ [ ] Ajouter un lien vers le site {pkgdown} du projet dans le crit\u00e8re 3 (auto-portant)",
      "+ [ ] Mettre ce ticket dans la colonne validation",
      "+ [ ] Faire en sorte que ce ticket soit valid\u00e9 en KickOff avec le client"
    )
  )
})

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITHUB_PAT") != "")
test_that("add_issue_clients_github works", {
  expect_true(inherits(add_issue_clients_github, "function"))
  user <- gh::gh("GET /user")
  owner <- user$login
  repo_name <- "my-new-repo-for-gh-testing"

  on.exit({
    # admin access (delete_repo scope)
    gh::gh(paste0("DELETE /repos/", owner, "/", repo_name))
  })

  gh::gh("POST /user/repos", name = repo_name)

  issue_client <-
    add_issue_clients_github(owner = owner, repo = repo_name)

  expect_gt(nrow(issue_client), 0)

  expect_match(
    object = issue_client[["title"]],
    regexp = "Bienvenue sur le suivi de projet GitHub"
  )

  expect_match(
    object = issue_client[["state"]],
    regexp = "open"
  )
})

test_that("create_issue_content_clients_github works", {
  expect_true(inherits(create_issue_content_clients_github, "function"))

  expect_equal(
    object = create_issue_content_clients_github(owner = "ThinkR-open", repo = "example-weekly"),
    expected = c(
      "# Bonjour et bienvenue sur notre outil de suivi de projet.",
      "",
      "_Si vous lisez ce message depuis vos emails, merci de cliquer sur le lien en bas \"View it on GitHub\" ou \"Lire sur GitHub\"._",
      "",
      "Ce site web est l\'outil de d\u00e9veloppement GitHub. Il nous permet de versionner notre code (conserver l\'historique des modifications) et de communiquer sur les fonctionnalit\u00e9s en cours de d\u00e9veloppement.",
      "",
      "Le message que vous lisez actuellement est un ticket de suivi (aussi appel\u00e9 \"issue\"). C\'est sous ce format que nous listons toutes les fonctionnalit\u00e9s demand\u00e9es et bugs divis\u00e9s en unit\u00e9s de d\u00e9veloppement. C\'est aussi sous ce format que la totalit\u00e9 de nos \u00e9changes devront \u00eatre stock\u00e9s. Nous \u00e9vitons les Emails pour conserver l\'historique des \u00e9changes, rang\u00e9s dans les tickets d\u00e9di\u00e9s, pour ne rien perdre de vos besoins et demandes.",
      "",
      "## Au cours du d\u00e9veloppement, nous vous demanderons de :",
      "",
      "- **r\u00e9pondre \u00e0 nos points de blocage**. Pour cela, comme pour le pr\u00e9sent ticket, vous serez notifi\u00e9s par un Email qui contient un lien pour venir sur l\'interface. Nous vous donnerons le plus d\'informations possibles sur le probl\u00e8me. Pour nous r\u00e9pondre, vous pouvez \u00e9crire un message dans la partie d\u00e9di\u00e9e ci-dessous, quand vous avez le temps de le faire. *Nous vous demandons d\'ailleurs de bien vouloir \u00e9crire un message d\u00e8s \u00e0 pr\u00e9sent et de le valider. Merci.*",
      "- **suivre l\'avancement du projet** dans le Kanban d\u00e9di\u00e9. Ce Kanban se trouve \u00e0 l\'adresse suivante que vous pouvez ouvrir d\u00e8s \u00e0 pr\u00e9sent dans un nouvel onglet : <https://github.com/ThinkR-open/example-weekly/projects/1>",
      "    + Vous verrez que le ticket que vous \u00eates en train de lire se trouve dans la colonne *\"Bloqu\u00e9\"*. Cette colonne de tickets vous est adress\u00e9e. Tous les tickets qui s\'y trouvent n\u00e9cessitent des informations compl\u00e9mentaires pour \u00eatre trait\u00e9s. En th\u00e9orie, vous aurez re\u00e7u un email pour chacun d\'entre eux, mais s\'il y en a trop, vous savez maintenant o\u00f9 les retrouver.",
      "- **valider les tickets termin\u00e9s**. Dans le Kanban, vous avez une colonne en fin de Kanban nomm\u00e9e *A valider*. Il s\'agit des tickets que nous consid\u00e9rons avoir impl\u00e9ment\u00e9s et qui n\u00e9cessitent validation de votre part.",
      "  + Lorsque vous pouvez faire la validation sans assistance de notre part, nous vous donnerons toutes les instructions pour savoir comment valider. Vous pourrez \u00e9crire un message du type : \"Je valide la fermeture de ce ticket.\"",
      "  + En cas de ticket plus complexe ou plus technique, nous le validerons ensemble lors d\'un point d\'avancement en direct. Auquel cas, nous validerons la fermeture dans le compte-rendu de r\u00e9union.",
      "",
      "## Comment valider les tickets ?",
      "",
      "La validation se fait par les commanditaires, sur les tickets ajout\u00e9s \u00e0 la colonne \"Validation\" du Projet: <https://github.com/ThinkR-open/example-weekly/projects/1>  ",
      "Vous verrez dans nos tickets qu\'il y a au moins trois parties:",
      "",
      "- ETQ (En tant que)",
      "- Crit\u00e8res de validation",
      "- Comment technique",
      "",
      "Ces parties s\'adressent en premier aux d\u00e9veloppeureuses pour savoir quoi et comment traiter le besoin.  ",
      "Lors de la validation, vous verrez la partie \"Crit\u00e8res de validation\" \u00e9voluer avec les consignes ou les captures d\'\u00e9cran qui vous permettent de valider le ticket. Nous vous demandons: ",
      "",
      "- De cocher les cases de chacun de ces crit\u00e8res si vous les valider",
      "- D\'ajouter un message dans le fil des commenaitres de l\'issue pour nous indiquer si vous le validez compl\u00e8tement, ou s\'il y a des corrections \u00e0 apporter.",
      "",
      "Ensuite, nous nous occupons de fermer le ticket et de r\u00e9-ouvrir tous ceux qui seraient n\u00e9cessaires.  ",
      "",
      "## Comptes-rendus",
      "",
      "Notez que nos \u00e9changes lors de r\u00e9unions en direct seront r\u00e9dig\u00e9s et accessibles pour vous dans :",
      "",
      "- [ ] Le Wiki de ce projet : <https://github.com/ThinkR-open/example-weekly/wiki>",
      "",
      "",
      "## Comment valider ce ticket ?",
      "",
      "Ce ticket est particulier, sa validation se fait par chaque nouvelle personne qui entre sur le projet.  ",
      "",
      "Merci de bien vouloir nous indiquer que vous avez lu et approuv\u00e9 \u00e0 la date d\'aujourd\'hui ce mode de fonctionnement en \u00e9crivant : \"lu et approuv\u00e9, le {date du jour}\" (Mettre la date du jour) dans un message ci-dessous (Emplacement \"Write\" ou \"Ecrire\") et valider l\'envoi du message en cliquant sur le bouton vert \"Comment\" ou \"Envoyer\".",
      "Suite \u00e0 quoi, nous nous chargerons de fermer ce ticket."
    )
  )
})

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITHUB_PAT") != "")
test_that("add_issue_dev_github works", {
  expect_true(inherits(add_issue_dev_github, "function"))

  user <- gh::gh("GET /user")
  owner <- user$login
  repo_name <- "my-new-repo-for-gh-testing"

  on.exit({
    # admin access (delete_repo scope)
    gh::gh(paste0("DELETE /repos/", owner, "/", repo_name))
  })

  gh::gh("POST /user/repos", name = repo_name)

  issue_client <-
    add_issue_dev_github(owner = owner, repo = repo_name)

  expect_gt(nrow(issue_client), 0)

  expect_match(
    object = issue_client[["title"]],
    regexp = "\\[dev\\] Checklist mise en place"
  )

  expect_match(
    object = issue_client[["state"]],
    regexp = "open"
  )
})

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITHUB_PAT") != "")
test_that("create_issue_content_dev_github works", {
  expect_true(inherits(create_issue_content_dev_github, "function"))

  user <- gh::gh("GET /user")
  owner <- user$login
  repo_name <- "my-new-repo-for-gh-testing"


  on.exit({
    # admin access (delete_repo scope)
    gh::gh(paste0("DELETE /repos/", owner, "/", repo_name))
  })

  gh::gh("POST /user/repos", name = repo_name)

  cible <- create_issue_content_dev_github(
    owner = owner,
    repo = repo_name
  )

  expect_match(
    object = cible,
    regexp = owner,
    all = FALSE
  )

  expect_match(
    object = cible,
    regexp = repo_name,
    all = FALSE
  )
})

## 04-05-2023 On skip pour des raisons d'auth sur le CI
skip_on_ci()
skip_if_not(Sys.getenv("GITHUB_PAT") != "")
test_that("add_issue_kickoff_github works", {
  # run depending on env variable value
  user <- gh::gh("GET /user")
  owner <- user$login
  repo_name <- "my-new-repo-for-gh-testing"

  on.exit({
    # admin access (delete_repo scope)
    gh::gh(paste0("DELETE /repos/", owner, "/", repo_name))
  })

  gh::gh("POST /user/repos", name = repo_name)


  issue_kkoff <- add_issue_kickoff_github(owner = owner, repo = repo_name)

  expect_gt(
    nrow(issue_kkoff),
    0
  )

  expect_match(
    object = issue_kkoff[["title"]],
    regexp = "ETQ client, j\'ai compris le fonctionnement de la validation des tickets"
  )

  expect_match(
    object = issue_kkoff[["state"]],
    regexp = "open"
  )

  # check nothing is done is issue is already open
  expect_message(
    object = add_issue_kickoff_github(
      owner = owner,
      repo = repo_name
    ),
    regexp = "The Kickoff issue is already open"
  )

  # close issue
  issue_number <- issue_kkoff[["number"]]
  gh(
    "PATCH /repos/{owner}/{repo}/issues/{issue_number}",
    owner = owner,
    repo = repo_name,
    issue_number = issue_number,
    state = "closed"
  )
})
